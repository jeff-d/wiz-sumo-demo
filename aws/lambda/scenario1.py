import os
import json
import random
import string
import base64
import logging
from datetime import datetime
import boto3
from botocore.exceptions import ClientError
from botocore.config import Config

# constants
# some assume a lab generated by the open source project at quicklab.io
scriptname = os.environ["AWS_LAMBDA_FUNCTION_NAME"]
region = os.environ["AWS_REGION"]
lab_id = os.environ["QUICKLAB_LAB_ID"]
project = os.environ["QUICKLAB_PROJECT"]
app_name = os.environ["APP_NAME"]

# set up boto3 retry options
config = Config(retries={"max_attempts": 5, "mode": "standard"})

# set up logging
logging.basicConfig(
    format="[%(levelname)-4s, line %(lineno)d] %(message)s",
    datefmt="%d-%m-%Y:%H:%M:%S",
    level=logging.getLevelName(os.environ["LOGGING_LEVEL"]),
    force=True,
)
logger = logging.getLogger(__name__)


def parse_arn(arn):
    # https://gist.github.com/gene1wood/5299969edc4ef21d8efcfea52158dd40
    # http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html
    elements = arn.split(":", 5)
    result = {
        "arn": elements[0],
        "partition": elements[1],
        "service": elements[2],
        "region": elements[3],
        "account": elements[4],
        "resource": elements[5],
        "resource_type": None,
    }
    if "/" in result["resource"]:
        result["resource_type"], result["resource"] = result["resource"].split("/", 1)
    elif ":" in result["resource"]:
        result["resource_type"], result["resource"] = result["resource"].split(":", 1)
    return result


def create_user():
    """
    Creates an IAM user.
        Parameters:
            none
        Returns:
            user_name (str): the name of the created IAM user
    """

    now = datetime.now().isoformat(timespec="seconds")

    user_name = os.environ["USER_NAME"]

    # create IAM client
    iam = boto3.client("iam")

    # create a User
    r = iam.create_user(
        Path="/",
        UserName=user_name,
        PermissionsBoundary="arn:aws:iam::aws:policy/AmazonEC2ReadOnlyAccess",
        Tags=[
            {"Key": "LabId", "Value": lab_id},
            {"Key": "Project", "Value": project},
            {"Key": "CreatedWith", "Value": scriptname},
            {"Key": "CreatedAt", "Value": now},
        ],
    )
    logger.debug(f"create_user response: {r}")

    created_user = r["User"]["UserName"]

    return created_user


def create_secret(user_name, secret_string):
    """
    Places an AccessKeyId in a Secrets Manager secret.
        Parameters:
            user_name (str): the IAM user associated with the access key.
            secret_string (str): the AcecssKeyId to store in the secret.
        Returns:
            secret_name (str): the secret name
            secret_id (str): the secret id
    """

    now = datetime.now().isoformat(timespec="seconds")

    # create Secrets Manager client
    secretsmanager = boto3.client("secretsmanager")

    # create a Secret
    r = secretsmanager.create_secret(
        Name=f"{user_name}-credentials",
        Description="the most recently-generated AccessKeyId and SecretAccessKey for this user",
        SecretString=f"{secret_string}",
        Tags=[
            {"Key": "LabId", "Value": lab_id},
            {"Key": "Project", "Value": project},
            {"Key": "CreatedWith", "Value": scriptname},
            {"Key": "CreatedAt", "Value": now},
        ],
    )

    secret_name = r["Name"]
    secret_arn = r["ARN"]

    parsed_arn = parse_arn(secret_arn)
    logger.debug(f"parsed secret_arn: {parsed_arn}")
    secret_id = parsed_arn["resource"]

    return secret_name, secret_id


def put_secret_value(secret_name, secret_string):
    """
    Places an AccessKeyId in a Secrets Manager secret.
        Parameters:
            secret_name (str): the Secrets Manager secret whose value will be updated.
            secret_string (str): the AcecssKeyId to store in the secret.
        Returns:
            secret_version (str): the updated Secret's version id
    """

    # create Secrets Manager client
    secretsmanager = boto3.client("secretsmanager")

    # update a Secret's value
    r = secretsmanager.put_secret_value(
        SecretId=f"{secret_name}",  # The ARN or name of the secret to add a new version to.
        SecretString=f"{secret_string}",
    )

    secret_version = r["VersionId"]

    return secret_version


def list_secrets(secret_name):
    """
    Lists existing Secrets Manager secret.
        Parameters:
            secret_name (str): a Secret Name to check.
        Returns:
            existing_secrets (obj): a filtered list of secrets
    """

    # create Secrets Manager client
    secretsmanager = boto3.client("secretsmanager")

    # retrieve Secrets
    existing_secrets = secretsmanager.list_secrets(
        IncludePlannedDeletion=True,
        Filters=[
            {
                "Key": "name",
                "Values": [
                    f"{secret_name}",
                ],
            },
        ],
    )

    return existing_secrets


def create_access_key(user_name):
    """
    Creates a new IAM Access Key.
        Parameters:
            user_name (str): the IAM user who needs a new key
        Returns:
            access_key (str): the Access Key ID of the new key
    """

    # create IAM client
    iam = boto3.client("iam")

    # create an Access Key
    r = iam.create_access_key(UserName=f"{user_name}")
    logger.debug(f"create_access_keys response: {r}")
    access_key_id = r["AccessKey"]["AccessKeyId"]
    secret_access_key = r["AccessKey"]["SecretAccessKey"]

    return access_key_id, secret_access_key


def list_access_keys(user_name):
    """
    Lists IAM Access Keys for a user.
        Parameters:
            user_name (str): the IAM user who needs a new key
        Returns:
            existing_access_keys (obj): information about the access key IDs
            associated with the specified IAM user. If there is none,
            the operation returns an empty list.
    """

    # Create IAM client
    iam = boto3.client("iam")

    # List Access Keys
    existing_access_keys = iam.list_access_keys(UserName=f"{user_name}")

    return existing_access_keys


def get_launch_template_data():
    """
    Retrieves LaunchTemplateData for an EC2 Launch Template.
    Parameters:
        n/a
    Returns:
        template_version (int): the current version number of the launch template.
        template_data (obj): a JSON structure. Example here: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2/client/describe_launch_template_versions.html
    """

    # Create EC2 client
    ec2 = boto3.client("ec2")

    r = ec2.describe_launch_template_versions(
        LaunchTemplateName=f"{app_name}-al2023-apache"
    )
    logger.debug(f"describe_launch_template_version response: {r}")
    name = r["LaunchTemplateVersions"][0]["LaunchTemplateName"]
    description = r["LaunchTemplateVersions"][0]["VersionDescription"]
    version = r["LaunchTemplateVersions"][0]["VersionNumber"]
    data = r["LaunchTemplateVersions"][0]["LaunchTemplateData"]

    return name, description, version, data


def update_launch_template(user_name):
    """
    Updates the launch template created by QuickLab's app.sh with user data
    containing an apache default page that intentionally prints a user's access keys.
        Parameters:
            user_name (str):    the just-created IAM user whose credentials will be leaked
                                by instances launched from this updated launch template.
        Returns:
            launch_template_version (str):
    """

    # Create EC2 client
    ec2 = boto3.client("ec2")

    # get current launch template data
    name, description, version, data = get_launch_template_data()
    logger.info(
        f"Retrieved {name} template data from version {version} ({description})"
    )

    # get current UserData string
    ud = data["UserData"]
    logger.info(f"ud: {ud}")

    # new UserData content
    lambda_fs_root = os.environ["LAMBDA_TASK_ROOT"]
    user_data_path = f"{lambda_fs_root}/user-data.sh"
    user_data = open(user_data_path, encoding="ascii").read()

    # must be base64-encoded (16KB size limit)
    # https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2/client/create_launch_template_version.html
    user_data_bytes = user_data.encode("ascii")
    b64_user_data_bytes = base64.b64encode(user_data_bytes)
    b64_user_data = b64_user_data_bytes.decode("ascii")
    logger.info(f"b64_user_data: {b64_user_data}")

    # update UserData
    data["UserData"].replace(ud, b64_user_data)

    # update description
    now = datetime.now().isoformat(timespec="seconds")
    description = f"updates user data for wiz-sumo-demo default apache page ({now})"

    # add additional tags
    new_tags = [
        {"Key": "USER_NAME", "Value": user_name},
        {"Key": "UpdatedWith", "Value": scriptname},
        {"Key": "UpdatedAt", "Value": now},
    ]
    for tag in new_tags:
        data["TagSpecifications"][0]["Tags"].append(tag)

    # update launch template
    r = ec2.create_launch_template_version(
        LaunchTemplateName=name,
        VersionDescription=description,
        LaunchTemplateData=data,
    )
    launch_template_version = r["LaunchTemplateVersion"]["VersionNumber"]
    logger.info(f"Updated Launch template {name} using {user_data_path}.")

    return launch_template_version


def start_instance_refresh():
    """
    Starts an Instance Refresh for an Autoscaling Group
        Parameters:
            none
        Returns:
            refresh_id (str) The ID of the Instance Refresh
    """

    # Create EC2 client
    autoscaling = boto3.client("autoscaling")

    r = autoscaling.start_instance_refresh(
        AutoScalingGroupName=f"{project}-asg",
        Strategy="Rolling",
        Preferences={
            "InstanceWarmup": 0,
            "MinHealthyPercentage": 100,
            "MaxHealthyPercentage": 100,
            "SkipMatching": False,
            "AutoRollback": False,
            "ScaleInProtectedInstances": "Ignore",
            "StandbyInstances": "Ignore",
        },
    )

    refresh_id = r["InstanceRefreshId"]
    return refresh_id


def lambda_handler(event, context):
    """
    Looks for the iam.DeleteAccessKey CloudTrail event and generates a replacement access key
    for that IAM user, storing the AccessKeyId and SecretAccessKey in a Secrets Manager secret.
        Parameters:
            event (obj):    CloudTrail event passed via EventBridge,
                            or a custom payload used when invoking manually
            context (obj):  Lambda Execution context
        Returns:
            results (obj):  a list of actions taken during this script execution

    """
    detail_type = event["detail-type"]
    event_name = event["detail"]["eventName"]

    logger.info(f"processing {detail_type}: {event_name}...")
    logger.debug(f"event: {event}, context: {context}")

    actions = []
    results = {"scriptname": scriptname, "event": event_name, "actions_taken": actions}

    # early exit: we only care about the DeleteAccessKey IAM event,
    # or a manual invocation using the event_name "FirstInvoke"
    try:
        if event_name not in ["FirstInvoke", "DeleteAccessKey"]:
            logger.info(f"Event is {event_name}. Exiting...")
            results.update(early_exit="true")
            return json.dumps(results)
    except ClientError as e:
        logger.error(e)

    # on first invoke, create a new IAM user and update ASG launch template
    # with new user dat©a
    if event_name == "FirstInvoke":
        results.update(first_invoke="true")

        # create new IAM user
        try:
            user_name = create_user()
            logger.info(f"Created IAM User: {user_name}")
            actions.append("create_user")
        except ClientError as e:
            logger.error(e)

        # update launch template
        try:
            launch_template_version = update_launch_template(user_name)
            logger.info(f"Updated Launch Template version: {launch_template_version}")
            actions.append("update_launch_template")
        except ClientError as e:
            logger.error(e)

    # if processing DeleteAccessKey, exit early if possible, otherwise set some variables
    if event_name == "DeleteAccessKey":
        # early exit: we only care about responding to CloudTrail events triggered
        # by the Sumo Logic Automation Service
        try:
            user_agent = event["detail"]["userAgent"]
            if user_agent == "AWS Internal":
                logger.info(
                    f"Event {event_name} manually triggered via AWS Console. Exiting..."
                )
                results.update(early_exit="true")
                return json.dumps(results)
        except ClientError as e:
            logger.error(e)

        req_params = event["detail"]["requestParameters"]
        logger.debug(f"request parameters: {req_params}")
        user_name = req_params["userName"]

    # early exit: user already has 2 Access Keys
    try:
        existing_access_keys = list_access_keys(user_name)
        logger.debug(f"existing_access_keys: {existing_access_keys}")
        access_key_metadata = existing_access_keys["AccessKeyMetadata"]
        num_keys = len(access_key_metadata)

        if num_keys > 1:
            logger.info(
                f"User {user_name} already has {num_keys} Access Keys. Exiting..."
            )
            actions.append("list_access_keys")
            results.update(early_exit="true")
            return json.dumps(results)
        else:
            logger.info(f"User {user_name} has {num_keys} Access Key(s).")
    except ClientError as e:
        logger.error(e)

    # create new Access Key
    try:
        access_key_id, secret_access_key = create_access_key(user_name)
        logger.info(
            f"Created new access key with Access Key Id: ******{access_key_id[-4::]} and Secret Access Key ******{secret_access_key[-4::]}"
        )
        actions.append("create_access_key")
    except ClientError as e:
        logger.error(e)

    # create or update Secret (as appropriate)
    try:
        secret_string = f"{access_key_id},{secret_access_key}"
        secret_name = f"{user_name}-credentials"
        secret_list = list_secrets(secret_name)
        # ["SecretList"][0]["Name"]
        logger.debug(f"secret_list: {secret_list}")

        if len(secret_list["SecretList"]) == 0:
            # need to create new secret
            secret_name, secret_id = create_secret(user_name, secret_string)
            logger.info(f"Created new secret. Secret ID: {secret_id}")
            actions.append("create_secret")
        else:
            # need to update value of existing secret
            secret_version = put_secret_value(secret_name, secret_string)
            logger.info(f"Updated secret: {secret_name}. Version: {secret_version}")
            actions.append("put_secret_value")
    except ClientError as e:
        logger.error(e)

    # on first invoke, start ASG instance refresh to leak new access key from Secret
    if event_name == "FirstInvoke":
        try:
            refresh_id = start_instance_refresh()
            logger.info(f"Started Instance Refresh: {refresh_id}")
            actions.append("start_instance_refresh")
        except ClientError as e:
            logger.error(e)

    # return final function execution results
    return json.dumps(results)
